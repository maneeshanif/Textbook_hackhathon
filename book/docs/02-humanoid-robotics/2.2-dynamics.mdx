---
id: dynamics
title: 2.2 Dynamics
sidebar_position: 2
---

# 2.2 Dynamics

## Introduction

**Dynamics** studies the relationship between forces, torques, and motion. For humanoid robots, dynamics enables:

1. **Forward Dynamics**: Given torques, predict motion
2. **Inverse Dynamics**: Given desired motion, compute required torques
3. **Simulation**: Model robot behavior in physics engines

## Newton-Euler Equations

### Newton's Second Law (Translation)

$$
\mathbf{F} = m \mathbf{a}
$$

Where:
- $\mathbf{F}$: Net force on object
- $m$: Mass
- $\mathbf{a}$: Acceleration

### Euler's Equation (Rotation)

$$
\boldsymbol{\tau} = I \boldsymbol{\alpha} + \boldsymbol{\omega} \times (I \boldsymbol{\omega})
$$

Where:
- $\boldsymbol{\tau}$: Net torque
- $I$: Inertia tensor
- $\boldsymbol{\alpha}$: Angular acceleration
- $\boldsymbol{\omega}$: Angular velocity

## Lagrangian Dynamics

### The Lagrangian

$$
L = T - V
$$

Where:
- $T$: Kinetic energy
- $V$: Potential energy

### Euler-Lagrange Equation

$$
\frac{d}{dt}\left(\frac{\partial L}{\partial \dot{q}_i}\right) - \frac{\partial L}{\partial q_i} = \tau_i
$$

This gives the equations of motion for a multi-joint robot.

## Equation of Motion (Standard Form)

For a robot with $n$ joints:

$$
M(\mathbf{q}) \ddot{\mathbf{q}} + C(\mathbf{q}, \dot{\mathbf{q}}) \dot{\mathbf{q}} + G(\mathbf{q}) = \boldsymbol{\tau}
$$

Where:
- $M(\mathbf{q})$: **Inertia matrix** (mass effects)
- $C(\mathbf{q}, \dot{\mathbf{q}})$: **Coriolis and centrifugal forces**
- $G(\mathbf{q})$: **Gravity vector**
- $\boldsymbol{\tau}$: **Joint torques** (control input)

## Inverse Dynamics

**Problem**: Given desired trajectory $\mathbf{q}(t), \dot{\mathbf{q}}(t), \ddot{\mathbf{q}}(t)$, compute required torques $\boldsymbol{\tau}(t)$.

**Solution**: Rearrange equation of motion:

$$
\boldsymbol{\tau} = M(\mathbf{q}) \ddot{\mathbf{q}} + C(\mathbf{q}, \dot{\mathbf{q}}) \dot{\mathbf{q}} + G(\mathbf{q})
$$

### Example: Single Pendulum

For a simple pendulum with mass $m$, length $L$, and angle $\theta$:

**Equation of Motion:**

$$
mL^2 \ddot{\theta} + mgL \sin\theta = \tau
$$

**Python Simulation:**

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

def pendulum_dynamics(state, t, m=1.0, L=1.0, g=9.81, tau=0.0):
    """
    Dynamics of a simple pendulum.
    
    state = [theta, theta_dot]
    """
    theta, theta_dot = state
    theta_ddot = (tau - m * g * L * np.sin(theta)) / (m * L**2)
    return [theta_dot, theta_ddot]

# Initial conditions: 90 degrees, zero velocity
state0 = [np.pi / 2, 0.0]
t = np.linspace(0, 5, 500)

# Simulate free swing (no torque)
states = odeint(pendulum_dynamics, state0, t)
theta = states[:, 0]

plt.plot(t, np.degrees(theta))
plt.xlabel('Time (s)')
plt.ylabel('Angle (degrees)')
plt.title('Pendulum Free Swing')
plt.grid()
plt.show()
```

## Computed Torque Control

A control strategy that uses inverse dynamics to track a desired trajectory.

### Algorithm

1. Measure current state: $\mathbf{q}(t), \dot{\mathbf{q}}(t)$
2. Compute tracking error: $\mathbf{e} = \mathbf{q}_d - \mathbf{q}$
3. Design desired acceleration: $\ddot{\mathbf{q}}_d = \ddot{\mathbf{q}}_{\text{ref}} + K_p \mathbf{e} + K_d \dot{\mathbf{e}}$
4. Compute torques via inverse dynamics: $\boldsymbol{\tau} = M \ddot{\mathbf{q}}_d + C \dot{\mathbf{q}} + G$

This **linearizes** the system and enables precise trajectory tracking.

## Inertia Matrix Properties

### Symmetry

$$
M(\mathbf{q}) = M(\mathbf{q})^T
$$

### Positive Definiteness

$$
\mathbf{x}^T M(\mathbf{q}) \mathbf{x} > 0 \quad \forall \mathbf{x} \neq 0
$$

This ensures the matrix is invertible, critical for control.

## Forward Dynamics

**Problem**: Given current state $\mathbf{q}, \dot{\mathbf{q}}$ and torques $\boldsymbol{\tau}$, compute acceleration $\ddot{\mathbf{q}}$.

**Solution**: Solve for acceleration:

$$
\ddot{\mathbf{q}} = M^{-1}(\boldsymbol{\tau} - C \dot{\mathbf{q}} - G)
$$

Used in physics simulation engines (MuJoCo, PyBullet, Isaac Sim).

## Contact Dynamics

When a robot interacts with the environment (e.g., foot on ground), we must model **contact forces**.

### Equations with Contact

$$
M \ddot{\mathbf{q}} + C \dot{\mathbf{q}} + G = \boldsymbol{\tau} + J_c^T \mathbf{F}_c
$$

Where:
- $J_c$: Jacobian at contact point
- $\mathbf{F}_c$: Contact force

### Friction Models

**Coulomb Friction**: Static and kinetic friction

$$
F_{\text{friction}} \leq \mu F_{\text{normal}}
$$

Where $\mu$ is the coefficient of friction.

## Energy Considerations

### Kinetic Energy

$$
T = \frac{1}{2} \dot{\mathbf{q}}^T M(\mathbf{q}) \dot{\mathbf{q}}
$$

### Potential Energy

$$
V = \sum_{i=1}^n m_i g h_i
$$

Where $h_i$ is the height of link $i$.

### Power

$$
P = \boldsymbol{\tau}^T \dot{\mathbf{q}}
$$

Energy efficiency is critical for battery-powered humanoids.

## Key Takeaways

- **Inverse Dynamics**: Desired motion → Required torques (for control)
- **Forward Dynamics**: Torques → Resulting motion (for simulation)
- **Equation of Motion**: $M \ddot{\mathbf{q}} + C \dot{\mathbf{q}} + G = \boldsymbol{\tau}$
- **Computed Torque Control**: Uses inverse dynamics for trajectory tracking
- **Contact Forces**: Must be included for walking and manipulation

---

**Next:** [2.3 Locomotion and Gait](./2.3-locomotion-gait)
