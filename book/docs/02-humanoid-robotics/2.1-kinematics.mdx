---
id: kinematics
title: 2.1 Kinematics
sidebar_position: 1
---

# 2.1 Kinematics

## Introduction

**Kinematics** is the study of motion without considering forces. For humanoid robots, kinematics answers:

1. **Forward Kinematics (FK)**: Given joint angles, where is the end-effector (hand, foot)?
2. **Inverse Kinematics (IK)**: Given a desired end-effector position, what joint angles achieve it?

## Forward Kinematics

### The Problem

A humanoid robot's arm has multiple joints (shoulder, elbow, wrist). Given the angle of each joint $\theta_1, \theta_2, \ldots, \theta_n$, compute the position of the hand in 3D space.

### Example: 2D Planar Arm

Consider a 2-link arm in 2D:

```
    L1        L2
 ●------●------●
(base) (joint) (hand)
 θ1      θ2
```

**Forward Kinematics Equations:**

$$
x = L_1 \cos(\theta_1) + L_2 \cos(\theta_1 + \theta_2)
$$

$$
y = L_1 \sin(\theta_1) + L_2 \sin(\theta_1 + \theta_2)
$$

### Python Implementation

```python
import numpy as np
import matplotlib.pyplot as plt

def forward_kinematics_2d(theta1, theta2, L1=1.0, L2=1.0):
    """
    Compute end-effector position for 2-link planar arm.
    
    Args:
        theta1: Angle of first joint (radians)
        theta2: Angle of second joint (radians)
        L1, L2: Link lengths
    
    Returns:
        (x, y): End-effector position
    """
    x = L1 * np.cos(theta1) + L2 * np.cos(theta1 + theta2)
    y = L1 * np.sin(theta1) + L2 * np.sin(theta1 + theta2)
    return x, y

# Example usage
theta1 = np.pi / 4  # 45 degrees
theta2 = np.pi / 6  # 30 degrees
x, y = forward_kinematics_2d(theta1, theta2)
print(f"End-effector position: ({x:.3f}, {y:.3f})")
```

**Output:**
```
End-effector position: (1.673, 1.183)
```

## Homogeneous Transformations

For 3D robots, we use **homogeneous transformation matrices** to represent translations and rotations.

### Transformation Matrix

A 4×4 matrix that combines rotation $R$ and translation $\mathbf{p}$:

$$
T = \begin{bmatrix}
R & \mathbf{p} \\\\
\mathbf{0} & 1
\end{bmatrix}
$$

Where $R$ is a 3×3 rotation matrix and $\mathbf{p}$ is the position vector.

**Example: Rotation around Z-axis + Translation**

$$
T = \begin{bmatrix}
\cos\theta & -\sin\theta & 0 & x \\
\sin\theta & \cos\theta & 0 & y \\
0 & 0 & 1 & z \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

### Chain of Transformations

For a multi-joint robot, the transformation from base to end-effector is the product of individual joint transformations:

$$
T_{\text{base}}^{\text{end}} = T_1 \cdot T_2 \cdot T_3 \cdots T_n
$$

## Denavit-Hartenberg (DH) Parameters

A standardized method to assign coordinate frames and compute forward kinematics.

### DH Parameters Table

For each joint $i$, define 4 parameters:

| Parameter | Description |
|-----------|-------------|
| $a_i$ | Link length (distance along $x_i$) |
| $\alpha_i$ | Link twist (rotation around $x_i$) |
| $d_i$ | Link offset (distance along $z_{i-1}$) |
| $\theta_i$ | Joint angle (rotation around $z_{i-1}$) |

### DH Transformation Matrix

$$
T_i = \begin{bmatrix}
\cos\theta_i & -\sin\theta_i \cos\alpha_i & \sin\theta_i \sin\alpha_i & a_i \cos\theta_i \\
\sin\theta_i & \cos\theta_i \cos\alpha_i & -\cos\theta_i \sin\alpha_i & a_i \sin\theta_i \\
0 & \sin\alpha_i & \cos\alpha_i & d_i \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

## Inverse Kinematics

### The Problem

Given a desired end-effector position $(x_d, y_d, z_d)$, find joint angles $\theta_1, \theta_2, \ldots, \theta_n$ that achieve it.

**Challenge:** Multiple solutions may exist (or no solution for unreachable positions).

### Analytical IK (2D Example)

For the 2-link planar arm:

$$
\theta_2 = \cos^{-1}\left(\frac{x^2 + y^2 - L_1^2 - L_2^2}{2 L_1 L_2}\right)
$$

$$
\theta_1 = \tan^{-1}\left(\frac{y}{x}\right) - \tan^{-1}\left(\frac{L_2 \sin\theta_2}{L_1 + L_2 \cos\theta_2}\right)
$$

### Python Implementation

```python
def inverse_kinematics_2d(x, y, L1=1.0, L2=1.0):
    """
    Compute joint angles for 2-link planar arm (analytical solution).
    
    Args:
        x, y: Desired end-effector position
        L1, L2: Link lengths
    
    Returns:
        (theta1, theta2): Joint angles in radians
    """
    # Check if position is reachable
    distance = np.sqrt(x**2 + y**2)
    if distance > (L1 + L2) or distance < abs(L1 - L2):
        raise ValueError("Position is unreachable")
    
    # Solve for theta2 (elbow angle)
    cos_theta2 = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    theta2 = np.arccos(cos_theta2)  # Elbow-down solution
    
    # Solve for theta1 (shoulder angle)
    k1 = L1 + L2 * np.cos(theta2)
    k2 = L2 * np.sin(theta2)
    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)
    
    return theta1, theta2

# Example usage
x_target, y_target = 1.5, 0.5
theta1, theta2 = inverse_kinematics_2d(x_target, y_target)
print(f"Joint angles: θ1={np.degrees(theta1):.2f}°, θ2={np.degrees(theta2):.2f}°")

# Verify with forward kinematics
x_fk, y_fk = forward_kinematics_2d(theta1, theta2)
print(f"FK verification: ({x_fk:.3f}, {y_fk:.3f})")
```

### Numerical IK (Jacobian Method)

For complex robots, analytical solutions are intractable. Use **iterative optimization**:

$$
\Delta \mathbf{q} = J^{-1} (\mathbf{x}_{\text{desired}} - \mathbf{x}_{\text{current}})
$$

Where $J$ is the **Jacobian matrix** relating joint velocities to end-effector velocity.

## Jacobian Matrix

The Jacobian $J$ maps joint velocities $\dot{\mathbf{q}}$ to end-effector velocity $\dot{\mathbf{x}}$:

$$
\dot{\mathbf{x}} = J(\mathbf{q}) \dot{\mathbf{q}}
$$

**For a 2-link arm:**

$$
J = \begin{bmatrix}
-L_1 \sin\theta_1 - L_2 \sin(\theta_1 + \theta_2) & -L_2 \sin(\theta_1 + \theta_2) \\
L_1 \cos\theta_1 + L_2 \cos(\theta_1 + \theta_2) & L_2 \cos(\theta_1 + \theta_2)
\end{bmatrix}
$$

### Applications of Jacobian

1. **Velocity Control**: Compute joint velocities to achieve desired end-effector velocity
2. **Force Control**: Relate joint torques to end-effector forces
3. **Singularity Analysis**: Identify configurations where control is lost ($\det(J) = 0$)

## Workspace Analysis

### Reachable Workspace

The set of all points the end-effector can reach with any orientation.

**For a 2-link arm:**
- **Outer radius**: $L_1 + L_2$
- **Inner radius**: $|L_1 - L_2|$
- **Shape**: Annulus (ring)

### Dexterous Workspace

Subset of reachable workspace where the robot can achieve multiple orientations.

## Key Takeaways

- **Forward Kinematics**: Joint angles → End-effector position (straightforward)
- **Inverse Kinematics**: Desired position → Joint angles (challenging, multiple solutions)
- **DH Parameters**: Standardized method for robot kinematics
- **Jacobian**: Maps joint velocities to end-effector velocities, critical for control
- **Workspace**: Reachable positions depend on link lengths and joint limits

---

**Next:** [2.2 Dynamics](./2.2-dynamics)
