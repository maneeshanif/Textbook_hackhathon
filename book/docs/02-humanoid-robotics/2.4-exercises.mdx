---
id: exercises
title: 2.4 Exercises
sidebar_position: 4
---

# 2.4 Exercises

## Kinematics Problems

### Problem 1: Forward Kinematics
**Difficulty:** Beginner

Given a 2-link planar arm with $L_1 = 0.8$ m, $L_2 = 0.6$ m, and joint angles $\theta_1 = 60°$, $\theta_2 = -30°$, compute the end-effector position.

<details>
<summary>Solution</summary>

Convert to radians: $\theta_1 = \pi/3$, $\theta_2 = -\pi/6$

$$
x = 0.8 \cos(60°) + 0.6 \cos(60° - 30°) = 0.8(0.5) + 0.6 \cos(30°) = 0.4 + 0.52 = 0.92 \text{ m}
$$

$$
y = 0.8 \sin(60°) + 0.6 \sin(30°) = 0.8(0.866) + 0.6(0.5) = 0.693 + 0.3 = 0.993 \text{ m}
$$

**Answer:** $(0.92, 0.993)$ m

</details>

---

### Problem 2: Inverse Kinematics
**Difficulty:** Intermediate

For the same 2-link arm, find joint angles to reach position $(1.2, 0.4)$ m. Use Python to verify your solution.

<details>
<summary>Solution Code</summary>

```python
import numpy as np

def inverse_kinematics_2d(x, y, L1=0.8, L2=0.6):
    # Check reachability
    distance = np.sqrt(x**2 + y**2)
    if distance > (L1 + L2):
        raise ValueError(f"Unreachable: distance={distance:.2f} > {L1 + L2}")
    
    # Solve for theta2
    cos_theta2 = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    theta2 = np.arccos(cos_theta2)  # Elbow-down
    
    # Solve for theta1
    k1 = L1 + L2 * np.cos(theta2)
    k2 = L2 * np.sin(theta2)
    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)
    
    return theta1, theta2

# Solve
theta1, theta2 = inverse_kinematics_2d(1.2, 0.4)
print(f"θ1 = {np.degrees(theta1):.2f}°")
print(f"θ2 = {np.degrees(theta2):.2f}°")

# Verify with forward kinematics
x_fk = 0.8 * np.cos(theta1) + 0.6 * np.cos(theta1 + theta2)
y_fk = 0.8 * np.sin(theta1) + 0.6 * np.sin(theta1 + theta2)
print(f"FK verification: ({x_fk:.3f}, {y_fk:.3f})")
```

**Output:**
```
θ1 = 3.98°
θ2 = 65.16°
FK verification: (1.200, 0.400)
```

</details>

---

## Dynamics Problems

### Problem 3: Pendulum Simulation
**Difficulty:** Intermediate

Simulate a simple pendulum with:
- Mass: 2 kg
- Length: 1.5 m
- Initial angle: 45°
- Initial velocity: 0 rad/s

Plot the angle vs. time for 5 seconds.

<details>
<summary>Solution Code</summary>

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

def pendulum_dynamics(state, t, m, L, g):
    theta, theta_dot = state
    theta_ddot = -(g / L) * np.sin(theta)
    return [theta_dot, theta_ddot]

# Parameters
m, L, g = 2.0, 1.5, 9.81
state0 = [np.radians(45), 0.0]
t = np.linspace(0, 5, 500)

# Simulate
states = odeint(pendulum_dynamics, state0, t, args=(m, L, g))
theta = np.degrees(states[:, 0])

# Plot
plt.figure(figsize=(10, 4))
plt.plot(t, theta)
plt.xlabel('Time (s)')
plt.ylabel('Angle (degrees)')
plt.title('Simple Pendulum Simulation')
plt.grid()
plt.axhline(0, color='black', linestyle='--', linewidth=0.5)
plt.show()
```

</details>

---

### Problem 4: Inverse Dynamics
**Difficulty:** Advanced

For a robot arm with inertia $I = 0.5$ kg·m², friction $b = 0.1$ N·m·s, compute the torque required to:
- Accelerate from rest to $\dot{\theta} = 1$ rad/s in 0.5 seconds
- Maintain constant velocity afterward

<details>
<summary>Solution</summary>

**Phase 1 (Acceleration):** $0 \leq t \leq 0.5$ s

$$
\ddot{\theta} = \frac{1 - 0}{0.5} = 2 \text{ rad/s}^2
$$

$$
\tau = I \ddot{\theta} + b \dot{\theta} = 0.5(2) + 0.1(1) = 1.1 \text{ N·m}
$$

**Phase 2 (Constant Velocity):** $t > 0.5$ s

$$
\ddot{\theta} = 0, \quad \dot{\theta} = 1 \text{ rad/s}
$$

$$
\tau = 0 + 0.1(1) = 0.1 \text{ N·m}
$$

</details>

---

## Locomotion Problems

### Problem 5: ZMP Calculation
**Difficulty:** Intermediate

A humanoid has:
- Total mass: 50 kg
- CoM at height: 0.8 m
- CoM horizontal position: $x_{\text{CoM}} = 0.05$ m (relative to ankle)
- CoM horizontal acceleration: $\ddot{x}_{\text{CoM}} = 0.2$ m/s²

Calculate the ZMP position.

<details>
<summary>Solution</summary>

**Simplified ZMP Equation (1D):**

$$
x_{\text{ZMP}} = x_{\text{CoM}} - \frac{h}{g} \ddot{x}_{\text{CoM}}
$$

$$
x_{\text{ZMP}} = 0.05 - \frac{0.8}{9.81} \times 0.2 = 0.05 - 0.0163 = 0.0337 \text{ m}
$$

**Answer:** ZMP is at 3.37 cm from the ankle.

</details>

---

### Problem 6: LIPM Simulation
**Difficulty:** Advanced

Implement a closed-loop LIPM controller:
- Initial CoM position: $x = 0$ m
- Target CoM position: $x_{\text{target}} = 0.1$ m
- CoM height: $h = 0.9$ m
- Control law: $x_{\text{ZMP}} = x_{\text{target}} - K(x - x_{\text{target}})$ with $K = 0.5$

Simulate for 2 seconds and plot CoM trajectory.

<details>
<summary>Solution Code</summary>

```python
import numpy as np
import matplotlib.pyplot as plt

def lipm_closed_loop(x_target, K=0.5, h=0.9, g=9.81, T=2.0, dt=0.01):
    time = np.arange(0, T, dt)
    x, x_dot = 0.0, 0.0
    trajectory = []
    
    for t in time:
        # Control law: proportional feedback
        x_zmp = x_target - K * (x - x_target)
        
        # LIPM dynamics
        x_ddot = (g / h) * (x - x_zmp)
        x_dot += x_ddot * dt
        x += x_dot * dt
        
        trajectory.append(x)
    
    return time, trajectory

time, x_trajectory = lipm_closed_loop(x_target=0.1)

plt.figure(figsize=(10, 4))
plt.plot(time, x_trajectory, label='CoM Position')
plt.axhline(0.1, color='red', linestyle='--', label='Target')
plt.xlabel('Time (s)')
plt.ylabel('Position (m)')
plt.title('LIPM Closed-Loop Control')
plt.legend()
plt.grid()
plt.show()
```

**Expected Result:** CoM converges to 0.1 m with some overshoot.

</details>

---

## Conceptual Questions

### Question 1: Jacobian Singularities
**Difficulty:** Intermediate

What happens when a robot arm reaches a singularity ($\det(J) = 0$)? Provide a physical example.

<details>
<summary>Answer</summary>

**At a singularity:**
- The Jacobian matrix becomes non-invertible
- Robot loses one or more degrees of freedom
- Small joint motions produce no end-effector motion in certain directions
- Infinite joint velocities may be required for certain end-effector velocities

**Physical Example: 2-Link Arm**

When $\theta_2 = 0$ (arm fully extended):
- End-effector can only move tangentially, not radially inward
- Jacobian determinant = 0
- Cannot generate force in the direction of the arm

**Control Implication:** Trajectory planning must avoid singularities, or use damped least squares: $\Delta \mathbf{q} = J^T(JJ^T + \lambda I)^{-1} \Delta \mathbf{x}$

</details>

---

### Question 2: Walking vs. Running
**Difficulty:** Beginner

Why is running more energy-efficient than walking at high speeds?

<details>
<summary>Answer</summary>

**Walking**: Double-support phases with inverted pendulum dynamics. Energy must be dissipated and regenerated each step.

**Running**: Ballistic flight phases allow energy storage in tendons/springs. Body acts like a bouncing ball, converting potential energy to kinetic energy and back.

**Crossover Speed:** ~2 m/s for humans. Below this, walking is more efficient. Above this, running is more efficient.

</details>

---

## Key Takeaways

- Kinematics: FK is straightforward, IK requires analytical or numerical methods
- Jacobian: Critical for velocity control and singularity analysis
- Dynamics: Equation of motion $M\ddot{\mathbf{q}} + C\dot{\mathbf{q}} + G = \boldsymbol{\tau}$
- ZMP: Must stay inside support polygon for stable walking
- LIPM: Simplified model for CoM trajectory generation

---

**Next:** [2.5 Summary](./2.5-summary)
