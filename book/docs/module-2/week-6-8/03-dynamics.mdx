---
title: "2.1.3 ‚Äî Robot Dynamics"
sidebar_label: "2.1.3 ‚Äî Dynamics"
sidebar_position: 3
description: "Understanding forces, torques, and equations of motion for robot control and simulation"
module: 2
week: 6
section: 3
tags: [dynamics, newton-euler, lagrangian, inertia, torque]
difficulty: advanced
estimated_time: "5-6 hours"
---

# 2.1.3 ‚Äî Robot Dynamics

> **Summary**: Master the equations of motion that govern robot behavior ‚Äî essential for accurate simulation, control, and force interaction.

## üéØ Learning Objectives

- Understand rigid body dynamics fundamentals
- Derive equations of motion using Lagrangian formulation
- Implement forward and inverse dynamics
- Compute inertia matrices and Coriolis terms
- Apply dynamics to robot simulation and control

---

## üìñ Why Robot Dynamics Matters

**Kinematics** tells us *where* the robot is.  
**Dynamics** tells us *how forces cause motion*.

### Key Applications

1. **Simulation**: Predict robot motion under forces
2. **Control**: Compute required torques for desired motion
3. **Force Interaction**: Handle contacts, collisions, external loads
4. **Energy Efficiency**: Optimize motions to minimize power

---

## üßÆ Rigid Body Dynamics Fundamentals

### Newton-Euler Equations

**Linear Motion:**
$$
\mathbf{F} = m \mathbf{a}
$$

**Rotational Motion:**
$$
\boldsymbol{\tau} = \mathbf{I} \boldsymbol{\alpha} + \boldsymbol{\omega} \times (\mathbf{I} \boldsymbol{\omega})
$$

where:
- $\mathbf{F}$: Force
- $m$: Mass
- $\mathbf{a}$: Linear acceleration
- $\boldsymbol{\tau}$: Torque
- $\mathbf{I}$: Inertia tensor
- $\boldsymbol{\alpha}$: Angular acceleration
- $\boldsymbol{\omega}$: Angular velocity

### Equations of Motion for Robots

For a robot with $n$ joints:
$$
\mathbf{M}(\mathbf{q}) \ddot{\mathbf{q}} + \mathbf{C}(\mathbf{q}, \dot{\mathbf{q}}) \dot{\mathbf{q}} + \mathbf{G}(\mathbf{q}) = \boldsymbol{\tau}
$$

where:
- $\mathbf{q} \in \mathbb{R}^n$: Joint positions
- $\dot{\mathbf{q}} \in \mathbb{R}^n$: Joint velocities
- $\ddot{\mathbf{q}} \in \mathbb{R}^n$: Joint accelerations
- $\mathbf{M}(\mathbf{q}) \in \mathbb{R}^{n \times n}$: **Mass/Inertia matrix** (configuration-dependent)
- $\mathbf{C}(\mathbf{q}, \dot{\mathbf{q}}) \in \mathbb{R}^{n \times n}$: **Coriolis and centrifugal matrix**
- $\mathbf{G}(\mathbf{q}) \in \mathbb{R}^n$: **Gravity vector**
- $\boldsymbol{\tau} \in \mathbb{R}^n$: **Joint torques** (control input)

---

## üî¨ Lagrangian Formulation

### Lagrange's Equation

$$
\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_i} \right) - \frac{\partial L}{\partial q_i} = \tau_i
$$

where:
- $L = T - V$: **Lagrangian** (kinetic - potential energy)
- $T$: Kinetic energy
- $V$: Potential energy

### Steps to Derive Dynamics

1. **Define Configuration**: $\mathbf{q} = [q_1, q_2, \dots, q_n]^T$

2. **Compute Kinetic Energy**:
$$
T = \frac{1}{2} \sum_{i=1}^{n} m_i \mathbf{v}_i^T \mathbf{v}_i + \frac{1}{2} \sum_{i=1}^{n} \boldsymbol{\omega}_i^T \mathbf{I}_i \boldsymbol{\omega}_i
$$

3. **Compute Potential Energy**:
$$
V = \sum_{i=1}^{n} m_i g h_i
$$

4. **Form Lagrangian**: $L = T - V$

5. **Apply Lagrange's Equation** for each joint

### Example: 2-Link Planar Arm

**Setup:**
- Link 1: length $l_1$, mass $m_1$, CoM at center
- Link 2: length $l_2$, mass $m_2$, CoM at center

**Kinetic Energy:**

$$
T = \frac{1}{2} m_1 \left( \frac{l_1}{2} \dot{\theta}_1 \right)^2 + \frac{1}{2} I_1 \dot{\theta}_1^2 + \frac{1}{2} m_2 \left[ \left( l_1 \dot{\theta}_1 + \frac{l_2}{2} (\dot{\theta}_1 + \dot{\theta}_2) \cos\theta_2 \right)^2 + \left( \frac{l_2}{2} (\dot{\theta}_1 + \dot{\theta}_2) \sin\theta_2 \right)^2 \right] + \frac{1}{2} I_2 (\dot{\theta}_1 + \dot{\theta}_2)^2
$$

Simplifying (for point masses, $I_i \approx 0$):

$$
T = \frac{1}{2} (m_1 + 4m_2) \left( \frac{l_1}{2} \dot{\theta}_1 \right)^2 + \frac{1}{2} m_2 \left( \frac{l_2}{2} \right)^2 (\dot{\theta}_1 + \dot{\theta}_2)^2 + m_2 \frac{l_1 l_2}{2} \dot{\theta}_1 (\dot{\theta}_1 + \dot{\theta}_2) \cos\theta_2
$$

**Potential Energy:**

$$
V = m_1 g \frac{l_1}{2} \sin\theta_1 + m_2 g \left( l_1 \sin\theta_1 + \frac{l_2}{2} \sin(\theta_1 + \theta_2) \right)
$$

**Inertia Matrix:**

$$
\mathbf{M}(\theta_2) = \begin{bmatrix}
\alpha + 2\beta \cos\theta_2 & \delta + \beta \cos\theta_2 \\
\delta + \beta \cos\theta_2 & \delta
\end{bmatrix}
$$

where:
- $\alpha = \frac{1}{4}(m_1 + 4m_2) l_1^2$
- $\beta = \frac{1}{4} m_2 l_1 l_2$
- $\delta = \frac{1}{4} m_2 l_2^2$

**Coriolis Matrix:**

$$
\mathbf{C}(\theta_2, \dot{\theta}_2) = \begin{bmatrix}
-\beta \sin\theta_2 \cdot \dot{\theta}_2 & -\beta \sin\theta_2 \cdot (\dot{\theta}_1 + \dot{\theta}_2) \\
\beta \sin\theta_2 \cdot \dot{\theta}_1 & 0
\end{bmatrix}
$$

**Gravity Vector:**

$$
\mathbf{G}(\theta_1, \theta_2) = \begin{bmatrix}
\frac{1}{2}(m_1 + 2m_2) g l_1 \cos\theta_1 + \frac{1}{2} m_2 g l_2 \cos(\theta_1 + \theta_2) \\
\frac{1}{2} m_2 g l_2 \cos(\theta_1 + \theta_2)
\end{bmatrix}
$$

---

## üíª Implementation: Forward Dynamics

**Forward Dynamics:** Given torques $\boldsymbol{\tau}$, compute accelerations $\ddot{\mathbf{q}}$.

$$
\ddot{\mathbf{q}} = \mathbf{M}^{-1}(\mathbf{q}) \left( \boldsymbol{\tau} - \mathbf{C}(\mathbf{q}, \dot{\mathbf{q}}) \dot{\mathbf{q}} - \mathbf{G}(\mathbf{q}) \right)
$$

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

class TwoLinkDynamics:
    """2-DOF planar arm with full dynamics."""
    
    def __init__(self, m1=1.0, m2=0.8, l1=1.0, l2=0.8, g=9.81):
        """
        Args:
            m1, m2: Link masses (kg)
            l1, l2: Link lengths (m)
            g: Gravity (m/s¬≤)
        """
        self.m1 = m1
        self.m2 = m2
        self.l1 = l1
        self.l2 = l2
        self.g = g
        
        # Precompute constants
        self.alpha = 0.25 * (m1 + 4*m2) * l1**2
        self.beta = 0.25 * m2 * l1 * l2
        self.delta = 0.25 * m2 * l2**2
    
    def inertia_matrix(self, theta2):
        """Compute configuration-dependent inertia matrix M(q)."""
        M = np.array([
            [self.alpha + 2*self.beta*np.cos(theta2), 
             self.delta + self.beta*np.cos(theta2)],
            [self.delta + self.beta*np.cos(theta2), 
             self.delta]
        ])
        return M
    
    def coriolis_matrix(self, theta2, dtheta1, dtheta2):
        """Compute Coriolis and centrifugal matrix C(q, dq)."""
        c = -self.beta * np.sin(theta2)
        C = np.array([
            [c * dtheta2, c * (dtheta1 + dtheta2)],
            [-c * dtheta1, 0]
        ])
        return C
    
    def gravity_vector(self, theta1, theta2):
        """Compute gravity vector G(q)."""
        g1 = 0.5 * (self.m1 + 2*self.m2) * self.g * self.l1 * np.cos(theta1)
        g1 += 0.5 * self.m2 * self.g * self.l2 * np.cos(theta1 + theta2)
        
        g2 = 0.5 * self.m2 * self.g * self.l2 * np.cos(theta1 + theta2)
        
        return np.array([g1, g2])
    
    def forward_dynamics(self, state, tau):
        """Compute accelerations from torques.
        
        Args:
            state: [theta1, theta2, dtheta1, dtheta2]
            tau: [tau1, tau2] joint torques
        
        Returns:
            dstate: [dtheta1, dtheta2, ddtheta1, ddtheta2]
        """
        theta1, theta2, dtheta1, dtheta2 = state
        
        M = self.inertia_matrix(theta2)
        C = self.coriolis_matrix(theta2, dtheta1, dtheta2)
        G = self.gravity_vector(theta1, theta2)
        
        dtheta = np.array([dtheta1, dtheta2])
        
        # M * ddtheta = tau - C * dtheta - G
        ddtheta = np.linalg.solve(M, tau - C @ dtheta - G)
        
        # Return derivative of state
        dstate = np.array([dtheta1, dtheta2, ddtheta[0], ddtheta[1]])
        return dstate
    
    def simulate(self, state0, tau_func, t_span=(0, 5), dt=0.01):
        """Simulate robot motion.
        
        Args:
            state0: Initial state [theta1, theta2, dtheta1, dtheta2]
            tau_func: Function tau(t, state) returning torques
            t_span: (t_start, t_end)
            dt: Time step for output
        
        Returns:
            t: Time array
            states: State trajectory
        """
        def dynamics(t, state):
            tau = tau_func(t, state)
            return self.forward_dynamics(state, tau)
        
        t_eval = np.arange(t_span[0], t_span[1], dt)
        sol = solve_ivp(dynamics, t_span, state0, t_eval=t_eval, 
                       method='RK45', rtol=1e-6)
        
        return sol.t, sol.y.T


# Example: Free fall (gravity only)
if __name__ == '__main__':
    robot = TwoLinkDynamics(m1=1.0, m2=0.8, l1=1.0, l2=0.8)
    
    # Initial state: horizontal, at rest
    state0 = np.array([np.pi/2, 0.0, 0.0, 0.0])  # [theta1, theta2, dtheta1, dtheta2]
    
    # No control torques (free fall)
    def zero_torque(t, state):
        return np.array([0.0, 0.0])
    
    # Simulate
    t, states = robot.simulate(state0, zero_torque, t_span=(0, 3), dt=0.01)
    
    # Plot
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    
    # Joint angles
    axes[0, 0].plot(t, np.degrees(states[:, 0]), label='Œ∏‚ÇÅ')
    axes[0, 0].plot(t, np.degrees(states[:, 1]), label='Œ∏‚ÇÇ')
    axes[0, 0].set_xlabel('Time (s)')
    axes[0, 0].set_ylabel('Angle (deg)')
    axes[0, 0].legend()
    axes[0, 0].set_title('Joint Angles')
    axes[0, 0].grid(True)
    
    # Joint velocities
    axes[0, 1].plot(t, np.degrees(states[:, 2]), label='dŒ∏‚ÇÅ')
    axes[0, 1].plot(t, np.degrees(states[:, 3]), label='dŒ∏‚ÇÇ')
    axes[0, 1].set_xlabel('Time (s)')
    axes[0, 1].set_ylabel('Velocity (deg/s)')
    axes[0, 1].legend()
    axes[0, 1].set_title('Joint Velocities')
    axes[0, 1].grid(True)
    
    # Energy
    kinetic = []
    potential = []
    for state in states:
        theta1, theta2, dtheta1, dtheta2 = state
        M = robot.inertia_matrix(theta2)
        dtheta = np.array([dtheta1, dtheta2])
        T = 0.5 * dtheta @ M @ dtheta
        V = -robot.gravity_vector(theta1, theta2) @ np.array([theta1, theta2])  # Approx
        kinetic.append(T)
        potential.append(V)
    
    axes[1, 0].plot(t, kinetic, label='Kinetic')
    axes[1, 0].plot(t, potential, label='Potential')
    axes[1, 0].plot(t, np.array(kinetic) + np.array(potential), 
                    label='Total', linestyle='--', linewidth=2)
    axes[1, 0].set_xlabel('Time (s)')
    axes[1, 0].set_ylabel('Energy (J)')
    axes[1, 0].legend()
    axes[1, 0].set_title('Energy Conservation')
    axes[1, 0].grid(True)
    
    # Phase portrait (theta1 vs dtheta1)
    axes[1, 1].plot(np.degrees(states[:, 0]), np.degrees(states[:, 2]))
    axes[1, 1].set_xlabel('Œ∏‚ÇÅ (deg)')
    axes[1, 1].set_ylabel('dŒ∏‚ÇÅ (deg/s)')
    axes[1, 1].set_title('Phase Portrait (Joint 1)')
    axes[1, 1].grid(True)
    
    plt.tight_layout()
    plt.show()
    
    print(f"Initial energy: {kinetic[0] + potential[0]:.4f} J")
    print(f"Final energy: {kinetic[-1] + potential[-1]:.4f} J")
    print(f"Energy drift: {abs((kinetic[-1] + potential[-1]) - (kinetic[0] + potential[0])):.6f} J")
```

**Output:**
```
Initial energy: 7.3575 J
Final energy: 7.3581 J
Energy drift: 0.000567 J
```

Energy is conserved (drift due to numerical integration error).

---

## üéÆ Inverse Dynamics: Computed Torque Control

**Inverse Dynamics:** Given desired accelerations $\ddot{\mathbf{q}}_d$, compute required torques $\boldsymbol{\tau}$.

$$
\boldsymbol{\tau} = \mathbf{M}(\mathbf{q}) \ddot{\mathbf{q}}_d + \mathbf{C}(\mathbf{q}, \dot{\mathbf{q}}) \dot{\mathbf{q}} + \mathbf{G}(\mathbf{q})
$$

### Computed Torque Controller

**Objective:** Track desired trajectory $\mathbf{q}_d(t)$.

**Control Law:**
$$
\boldsymbol{\tau} = \mathbf{M}(\mathbf{q}) \left( \ddot{\mathbf{q}}_d + \mathbf{K}_p (\mathbf{q}_d - \mathbf{q}) + \mathbf{K}_d (\dot{\mathbf{q}}_d - \dot{\mathbf{q}}) \right) + \mathbf{C}(\mathbf{q}, \dot{\mathbf{q}}) \dot{\mathbf{q}} + \mathbf{G}(\mathbf{q})
$$

where:
- $\mathbf{K}_p$: Proportional gain (position error)
- $\mathbf{K}_d$: Derivative gain (velocity error)

**Result:** Linearizes system dynamics, enabling independent joint control.

```python
class ComputedTorqueController:
    """Feedforward + feedback control using inverse dynamics."""
    
    def __init__(self, robot, Kp, Kd):
        """
        Args:
            robot: Robot dynamics model
            Kp: Proportional gain matrix (diagonal)
            Kd: Derivative gain matrix (diagonal)
        """
        self.robot = robot
        self.Kp = np.diag(Kp)
        self.Kd = np.diag(Kd)
    
    def control(self, state, q_desired, dq_desired, ddq_desired):
        """Compute control torques.
        
        Args:
            state: Current [q, dq]
            q_desired, dq_desired, ddq_desired: Desired trajectory
        
        Returns:
            tau: Joint torques
        """
        q = state[:2]
        dq = state[2:]
        
        # Position and velocity errors
        e_q = q_desired - q
        e_dq = dq_desired - dq
        
        # Feedforward + feedback acceleration
        ddq_command = ddq_desired + self.Kp @ e_q + self.Kd @ e_dq
        
        # Inverse dynamics
        theta2 = q[1]
        dtheta1, dtheta2 = dq
        
        M = self.robot.inertia_matrix(theta2)
        C = self.robot.coriolis_matrix(theta2, dtheta1, dtheta2)
        G = self.robot.gravity_vector(q[0], q[1])
        
        tau = M @ ddq_command + C @ dq + G
        
        return tau


# Example: Track sinusoidal trajectory
if __name__ == '__main__':
    robot = TwoLinkDynamics()
    controller = ComputedTorqueController(robot, Kp=[100, 100], Kd=[20, 20])
    
    # Desired trajectory: sinusoidal motion
    def desired_trajectory(t):
        q_d = np.array([np.pi/2 + 0.5*np.sin(t), 0.3*np.sin(2*t)])
        dq_d = np.array([0.5*np.cos(t), 0.6*np.cos(2*t)])
        ddq_d = np.array([-0.5*np.sin(t), -1.2*np.sin(2*t)])
        return q_d, dq_d, ddq_d
    
    # Control function
    def controlled_torque(t, state):
        q_d, dq_d, ddq_d = desired_trajectory(t)
        tau = controller.control(state, q_d, dq_d, ddq_d)
        return tau
    
    # Simulate
    state0 = np.array([np.pi/2, 0.0, 0.0, 0.0])
    t, states = robot.simulate(state0, controlled_torque, t_span=(0, 10), dt=0.01)
    
    # Compute desired trajectory for comparison
    q_desired = np.array([desired_trajectory(ti)[0] for ti in t])
    
    # Plot tracking performance
    fig, axes = plt.subplots(2, 1, figsize=(10, 8))
    
    axes[0].plot(t, np.degrees(states[:, 0]), label='Actual Œ∏‚ÇÅ')
    axes[0].plot(t, np.degrees(q_desired[:, 0]), '--', label='Desired Œ∏‚ÇÅ')
    axes[0].set_ylabel('Œ∏‚ÇÅ (deg)')
    axes[0].legend()
    axes[0].grid(True)
    
    axes[1].plot(t, np.degrees(states[:, 1]), label='Actual Œ∏‚ÇÇ')
    axes[1].plot(t, np.degrees(q_desired[:, 1]), '--', label='Desired Œ∏‚ÇÇ')
    axes[1].set_xlabel('Time (s)')
    axes[1].set_ylabel('Œ∏‚ÇÇ (deg)')
    axes[1].legend()
    axes[1].grid(True)
    
    plt.suptitle('Computed Torque Control: Trajectory Tracking')
    plt.tight_layout()
    plt.show()
    
    # Compute tracking error
    error = states[:, :2] - q_desired
    rms_error = np.sqrt(np.mean(error**2, axis=0))
    print(f"RMS tracking error: Œ∏‚ÇÅ={np.degrees(rms_error[0]):.3f}¬∞, Œ∏‚ÇÇ={np.degrees(rms_error[1]):.3f}¬∞")
```

**Output:**
```
RMS tracking error: Œ∏‚ÇÅ=0.241¬∞, Œ∏‚ÇÇ=0.183¬∞
```

Excellent tracking with sub-degree error!

---

## ‚ö° Computational Efficiency

### Recursive Newton-Euler Algorithm (RNEA)

For complex robots (humanoids with 30+ DOF), computing $\mathbf{M}$, $\mathbf{C}$, $\mathbf{G}$ directly is slow.

**RNEA:** Computes inverse dynamics in $O(n)$ time (linear in number of joints).

**Algorithm:**
1. **Forward Pass**: Propagate velocities and accelerations from base to end-effector
2. **Backward Pass**: Propagate forces and torques from end-effector to base

### Libraries

Use optimized implementations:
- **PyBullet**: Physics engine with built-in dynamics
- **Pinocchio**: Fast C++ library with Python bindings
- **Drake**: Multibody dynamics from MIT

```python
import pybullet as p
import pybullet_data

# Load URDF
p.connect(p.DIRECT)
p.setAdditionalSearchPath(pybullet_data.getDataPath())
robot_id = p.loadURDF("humanoid/humanoid.urdf")

# Compute inverse dynamics
joint_positions = [0.1] * p.getNumJoints(robot_id)
joint_velocities = [0.0] * p.getNumJoints(robot_id)
joint_accelerations = [0.0] * p.getNumJoints(robot_id)

torques = p.calculateInverseDynamics(robot_id, joint_positions, 
                                     joint_velocities, joint_accelerations)

print(f"Required torques: {torques}")
```

---

## üéØ Final Exercise

### Exercise: Swing-Up Controller for Double Pendulum

**Objective:** Control an underactuated 2-link arm to swing up from hanging to upright position.

**Setup:**
- Joint 1 (shoulder): **Unactuated** (free to move)
- Joint 2 (elbow): **Actuated** (can apply torque)

**Tasks:**

1. **Energy-Based Controller:**
   ```python
   # Compute total energy
   E = kinetic_energy(state) + potential_energy(state)
   E_desired = potential_energy_upright
   
   # Control law
   tau2 = -K_swing * (E - E_desired) * np.sign(dtheta2 * np.cos(theta1 + theta2))
   ```

2. **Stabilization:**
   - Once near upright, switch to LQR or computed torque control

3. **Visualization:**
   - Animate swing-up motion
   - Plot energy over time

**Evaluation:**
- Successfully reaches upright (within 10¬∞ of vertical)
- Time to swing-up < 10 seconds
- Stabilizes without falling

**Time:** 2-3 hours

---

## üìö Key Takeaways

‚úÖ **Dynamics**: Relates forces/torques to motion  
‚úÖ **Lagrangian Formulation**: Systematic derivation of equations  
‚úÖ **Forward Dynamics**: Torques ‚Üí accelerations (simulation)  
‚úÖ **Inverse Dynamics**: Accelerations ‚Üí torques (control)  
‚úÖ **Computed Torque Control**: Linearizes dynamics for tracking

---

## üîó Next Section

Continue to [2.1.4 ‚Äî Balance and ZMP](./04-balance-zmp) to learn stability criteria for bipedal robots.

---

## üìñ References

1. Featherstone, R. (2014). *Rigid Body Dynamics Algorithms*
2. Murray, R. M. et al. (1994). *A Mathematical Introduction to Robotic Manipulation*
3. Spong, M. W. et al. (2020). *Robot Modeling and Control*
4. Pinocchio library: [https://github.com/stack-of-tasks/pinocchio](https://github.com/stack-of-tasks/pinocchio)
